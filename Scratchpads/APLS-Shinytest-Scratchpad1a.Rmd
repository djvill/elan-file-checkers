---
title: "APLS file checker shinytest scratchpad 1a: Finish fixOverlaps()"
author: Dan Villarreal
date: Original 29 Sep 2022
output: 
  html_notebook:
    toc: yes
    toc_float: yes
    number_sections: yes
    code_folding: show
    df_print: tibble
---

```{css, echo=F}
pre {
  max-height: 300px;
  overflow-y: auto;
}
```


```{r setup}
knitr::opts_chunk$set(echo=T, include=T, comment=NA)
library(tidyverse)
library(magrittr)
library(shiny)
library(shinytest)
library(xml2)
```

# Intro

This is a continuation of Scratchpad 1, which I had to abort when SRW started acting up again & my laptop wasn't syncing Scratchpad1's chunk output correctly.
The goal is still to fix `fixOverlaps()`

I'm adding the following chunks from scratchpad1:

- funcs-from-app
- rewrite-findOverlapsTier
- rewrite-fixOverlaps

```{r funcs-from-app}
nonSpkrTiers <- c("Comment","Noise","Redaction")
overlapThresh <- 500

##Function that takes a tier name, eaf file, and file-wide time slot DF as
##  input and outputs actual times for annotations
getTimesTier <- function(tierName, eaf, timeSlots) {
  tierTimes <-
    ##Get all ALIGNABLE_ANNOTATION tags
    str_glue("//TIER[@TIER_ID='{tierName}']//ALIGNABLE_ANNOTATION") %>%
    xml_find_all(eaf, .) %>% 
    ##Get attributes as a dataframe
    xml_attrs() %>% 
    bind_rows()
  
  ##Add actual times, only if tier is nonempty
  if (nrow(tierTimes) > 0) {
    tierTimes <- tierTimes %>% 
      ##Add actual times
      left_join(timeSlots %>%
                  rename(TIME_SLOT_REF1 = TIME_SLOT_ID,
                         Start = TIME_VALUE),
                by="TIME_SLOT_REF1") %>%
      left_join(timeSlots %>%
                  rename(TIME_SLOT_REF2 = TIME_SLOT_ID,
                         End = TIME_VALUE),
                by="TIME_SLOT_REF2")
  } else {
    ##If tier is empty, return NULL (will be immediately discard()ed)
    NULL
  }
}

##Wrapper function around getTimesTier() that takes a single EAF file and name
##  (meant to be used with eaflist() reactive and imap()) plus multi-file tier
##  df (meant to be used with tierInfo() reactive) as input, and outputs nested
##  list of dataframes of annotation times (files at level one, tier DFs at
##  level two for speaker tiers only)
##N.B. This function outputs a list of DFs rather than a single DF because the
##  list structure makes it easier to detect overlaps in findOverlaps() (by
##  comparing the timings on a given speaker tier to all other speaker tiers)
getTimes <- function(eaf, eafName, df) {
  ##Timeslots (maps time slot ID to actual time, in milliseconds)
  timeSlots <- 
    ##Get TIME_SLOT nodes
    eaf %>% 
    xml_find_all("//TIME_SLOT") %>% 
    ##Get attributes as a dataframe
    xml_attrs() %>% 
    bind_rows() %>% 
    ##Make actual time numeric
    mutate(across(TIME_VALUE, as.numeric))
  
  ##Get speaker tier names
  spkrTierNames <- 
    ##df intended to be tierInfo() reactive
    df %>% 
    filter(File==eafName, SpkrTier) %>% 
    pull(TIER_ID)
  
  ##Get times for speaker tiers (list of dataframes)
  spkrTimes <- 
    spkrTierNames %>% 
    set_names(., .) %>% 
    map(getTimesTier, eaf, timeSlots) %>%
    ##Only nonempty tiers
    discard(is.null)
}

##Function that takes a single tier name and a nested list of annotation time
##  DFs (meant to be used with output of getTimes()), and outputs a single
##  dataframe: the relevant annotation time DF plus three boolean overlaps
##  columns (left, right, both), where TRUE means there is at least one
##  annotation on another tier whose (e.g.) left boundary is within the
##  annotation
findOverlapsTier <- function(tierName, timesEAF) {
  ##Get annotation timing DF for selected speaker
  spkr <- timesEAF %>% pluck(tierName)
  ##Get annotation timing DF that combines all other speakers
  otherSpkrs <-
    timesEAF %>%
    extract(names(.) != tierName) %>%
    bind_rows()
  
  ##For each boundary in selected tier, return the first annotation that the
  ##  boundary overlaps with, if any
  ##Currently isn't guaranteed to work with 3+ speaker tiers (because
  ##  which(x)[1] only selects the first result, not necessarily the result
  ##  closest to the boundary)
  bounds <- 
    spkr %>%
    ##One row per boundary (new columns Side, TIME_SLOT_REF, Time)
    rename(Time1 = Start, Time2 = End) %>% 
    pivot_longer(-ANNOTATION_ID, 
                 names_to=c(".value", "Side"), names_pattern="(.+)([12])") %>% 
    ##Check row-by-row (otherwise comparison in which() doesn't work)
    rowwise() %>% 
    ##Add overlap annotation ID
    ##N.B. This works because if which(x) is integer(0), which(x)[1] is NA
    mutate(ANNOTATION_ID_overlapped = otherSpkrs$ANNOTATION_ID %>% 
             extract(which(Time > otherSpkrs$Start & Time < otherSpkrs$End)[1])) %>% 
    ungroup()
  
  ##Restrict to boundaries with overlaps, and add information about overlapped
  ##  annotations
  overlapBounds <- 
    bounds %>%
    ##Only the boundaries that overlap another annotation
    filter(!is.na(ANNOTATION_ID_overlapped)) %>% 
    ##Add info about overlapped annotation
    left_join(otherSpkrs %>%
                rename_with(~ paste0(.x, "_overlapped")),
              by="ANNOTATION_ID_overlapped") %>% 
    ##Determine whether the nearest boundary is close enough (rowwise for min())
    rowwise() %>%
    mutate(StartDiff = abs(Start_overlapped - Time),
           EndDiff = abs(End_overlapped - Time),
           CloseEnough = min(StartDiff, EndDiff) < overlapThresh) %>%
    ungroup()
  
  ##Add new timeslot ID: if not close enough, "Too far"; if close enough, closer
  ##  boundary (tie goes to start boundary); anything else is unexpected so it
  ##  triggers an error below
  overlapBounds <- overlapBounds %>% 
    mutate(NewTS = case_when(
      !CloseEnough ~ "Too far",
      StartDiff <= EndDiff ~ TIME_SLOT_REF1_overlapped,
      StartDiff > EndDiff ~ TIME_SLOT_REF2_overlapped,
      TRUE ~ NA_character_),
      ##Add node path for fixing overlap
      NodePath = str_glue("//ALIGNABLE_ANNOTATION[@ANNOTATION_ID='{ANNOTATION_ID}']"))
  
  ##Return dataframe
  overlapBounds
}

##Check for problems with overlapBounds, fix any overlaps by modifying eaflist(),
##  and return overlapBounds with info about fixed boundaries
fixOverlapsTier <- function(overlapBounds, eaflist, eafName) {
  ##Check for boundaries where NewTS is NA
  if (any(is.na(overlapBounds$NewTS))) {
    stop("On tier ", tierName, 
         ", at least one boundary returned an error: ",
         overlapBounds %>% 
           filter(is.na(NewTS)) %>% 
           pull(ANNOTATION_ID) %>% 
           paste(collapse=" "))
  }
  
  ##Get fixed boundaries only
  overlapBoundsFixed <- 
    overlapBounds %>% 
    filter(NewTS != "Too far")
  
  ##If no boundaries fixed, return dataframe with all unresolved
  if (nrow(overlapBoundsFixed)==0) {
    overlapBounds <- overlapBounds %>% 
      mutate(Resolved = FALSE)
    return(overlapBounds)
  }
  
  ##Otherwise, check for issues in overlaps
  ##Check for annotation IDs that don't select a unique node within EAF file
  nodeCount <- 
    overlapBoundsFixed$NodePath %>% 
    map_int(~ xml_find_all(eaflist[[eafName]], .x) %>% 
              xml_length())
  if (any(nodeCount > 1)) {
    stop("On tier ", tierName, 
         ", at least one annotation ID doesn't select a unique node: ",
         overlapBoundsFixed %>% 
           filter(NodeCount > 1) %>% 
           pull(ANNOTATION_ID) %>% 
           paste(collapse=" "))
  }
  
  ##Check for annotations that have accidentally become 0-width
  ##This could happen if the annotation is less than overlapThresh wide and
  ##  is fully contained within another annotation on another tier. Could
  ##  mitigate this by re-running with a smaller overlapThresh
  zeroWidth <- 
    overlapBoundsFixed %>%
    select(ANNOTATION_ID:Time, NewTS) %>%
    pivot_wider(names_from=Side, names_glue="{.value}{Side}",
                values_from=TIME_SLOT_REF:NewTS) %>%
    filter(NewTS1==NewTS2)
  if (nrow(zeroWidth) > 0) {
    stop("On tier ", tierName, 
         ", at least one annotation was fixed to zero width:\n",
         "ANN_ID  Start   End\n",
         paste0(str_pad(zeroWidth$ANNOTATION_ID, 8, 'right'),
                str_pad(round(zeroWidth$Time1 / 1000, 1), 8, 'right'),
                str_pad(round(zeroWidth$Time2 / 1000, 1), 8, 'right'),
                "\n"))
  }
  
  ##Fix overlaps in eaflist()
  overlapBoundsFixed %>% 
    rowwise() %>% 
    group_walk(
      ~ eaflist %>% 
        pluck(eafName) %>% 
        xml_find_first(.x$NodePath) %>%
        ##Note xml_set_attr() modifies without assignment (!!!)
        xml_set_attr(paste0("TIME_SLOT_REF", .x$Side), .x$NewTS))
  
  ##Add fixed info to dataframe
  overlapBounds <- overlapBounds %>% 
    mutate(Resolved = NewTS!="Too far")
  
  ##Return dataframe
  overlapBounds
}

##Wrapper function around getTimesTier() that takes a *list* of DFs of
##  annotation times (one files' worth) and a single EAF name (meant to be used
##  with output of getTimes() and imap()), and outputs a *single* DF with 
##  annotation times plus overlaps columns
findOverlaps <- function(timesEAF, eafName) {
  ##Loop over tiers within this file to get overlaps
  timesEAF %>%
    names() %>%
    set_names(., .) %>%
    map(findOverlapsTier, timesEAF=timesEAF)
}

##Wrapper function around fixOverlapsTier() that takes a *list* of DFs of
##  annotation times (one file's worth) and a single EAF name (meant to be used
##  with output of getTimes() and imap()), and rotates through tiers, fixing
##  overlaps, until it reaches a stable state
fixOverlaps <- function(timesEAF, eaflist, eafName) {
  # ##Initialize empty overlap log
  # overlapLog <- data.frame(Tier = character(), 
  #                          NumBounds = character(),
  #                          NumOverlaps = character(),
  #                          NumFixed = character())
  
  ##Get initial overlaps
  overlapsInit <- 
    ##Get tier names
    timesEAF %>%
    names() %>% 
    set_names(., .) %>%
    ##Loop over tier names to find overlaps
    map(findOverlapsTier, timesEAF)
  
  ##Initialize looping variables
  overlapsPre <- NULL
  overlapsPost <- overlapsInit
  iters <- 0
  maxIter <- 10
  
  ##Continue until there are no remaining overlaps, either because all
  ##  overlaps have been fixed, or because things have stablized
  while (any(map_int(overlapsPost, nrow) > 0) && !identical(overlapsPre, overlapsPost)) {
    ##Increment iteration counter & stop if above maxIter
    iters <- iters + 1
    if (iters > maxIter) {
      stop("Overlap fixing reached max iterations (", maxIter, ")")
    }
    
    ##Old post is new pre
    overlapsPre <- overlapsPost
    
    ##Go through another fixing round
    overlapsPost <- 
      overlapsPre %>%
      map(fixOverlapsTier, eaflist, eafName) %>% 
      map(filter, !Resolved)
    
    message("iters: ", iters)
    message("nrow(overlapsPre): ", map_int(overlapsPre, nrow) %>% paste(collapse=" "))
    message("nrow(overlapsPost): ", map_int(overlapsPost, nrow) %>% paste(collapse=" "))
  }
  
  ##Return overlapsPost
  overlapsPost
}

##To be used for interactive debugging, not in actual app
xmllist_to_df <- function(xmllist, singleDF=TRUE, nST=nonSpkrTiers) {
  tierInfo <- 
    xmllist %>% 
    map(xml_find_all, "//TIER") %>% 
    ##One row per tier, with file info
    map_dfr(~ map_dfr(.x, xml_attrs), .id="File") %>% 
    ##Add SpkrTier (is the tier a speaker tier?)
    mutate(SpkrTier = !(tolower(PARTICIPANT) %in% tolower(nST)))
  
  eaflist <- imap(xmllist, getTimes, df=tierInfo)
  
  if (singleDF) {
    eaflist %>%
      map_dfr(~ map_dfr(.x, as_tibble, .id="Tier"), .id="File")
  } else {
    eaflist
  }
}

##Get a dataframe from several paths to EAFs
eafs_to_df <- function(..., singleDF=TRUE, nST=nonSpkrTiers) {
  eaflist <- list(...) %>% 
    flatten_chr() %>% 
    set_names(make.names(basename(.), unique=TRUE)) %>% 
    map(read_xml)
  
  xmllist_to_df(eaflist, singleDF=singleDF, nST=nST)
}

##Get a dataframe from a directory with several EAFs
eafDir_to_df <- function(eafDir, pattern=".+\\.eaf$", 
                         singleDF=TRUE, nST=nonSpkrTiers) {
  eaflist <- 
    dir(eafDir, pattern=pattern, full.names=TRUE) %>% 
    set_names(basename(.)) %>% 
    map(read_xml)
  
  xmllist_to_df(eaflist, singleDF=singleDF, nST=nST)
}
```

```{r rewrite-findOverlapsTier}
findOverlapsTier <- function(tierName, timesEAF) {
  ##Get annotation timing DF for selected speaker
  spkr <- timesEAF %>% pluck(tierName)
  ##Get annotation timing DF that combines all other speakers
  otherSpkrs <-
    timesEAF %>%
    extract(names(.) != tierName) %>%
    bind_rows()
  
  ##For each boundary in selected tier, return the first annotation that the
  ##  boundary overlaps with, if any
  ##Currently isn't guaranteed to work with 3+ speaker tiers (because
  ##  which(x)[1] only selects the first result, not necessarily the result
  ##  closest to the boundary)
  bounds <- 
    spkr %>%
    ##One row per boundary (new columns Side, TIME_SLOT_REF, Time)
    rename(Time1 = Start, Time2 = End) %>% 
    pivot_longer(-ANNOTATION_ID, 
                 names_to=c(".value", "Side"), names_pattern="(.+)([12])") %>% 
    ##Check row-by-row (otherwise comparison in which() doesn't work)
    rowwise() %>% 
    ##Add overlap annotation ID
    ##N.B. This works because if which(x) is integer(0), which(x)[1] is NA
    mutate(ANNOTATION_ID_overlapped = otherSpkrs$ANNOTATION_ID %>% 
             extract(which(Time > otherSpkrs$Start & Time < otherSpkrs$End)[1])) %>% 
    ungroup()
  
  ##Restrict to boundaries with overlaps & add information about overlapped
  ##  annotations
  overlapBounds <- 
    bounds %>%
    ##Only the boundaries that overlap another annotation
    filter(!is.na(ANNOTATION_ID_overlapped)) %>% 
    ##Add info about overlapped annotations
    left_join(otherSpkrs %>%
                rename_with(~ paste0(.x, "_overlapped")),
              by="ANNOTATION_ID_overlapped")
  
  ##Only proceed if there are any overlaps
  if (nrow(overlapBounds) > 0) {
    ##Add information about overlapped annotations
    overlapBounds <- overlapBounds %>% 
      ##Determine whether the nearest boundary is close enough (rowwise for min())
      rowwise() %>%
      mutate(StartDiff = abs(Start_overlapped - Time),
             EndDiff = abs(End_overlapped - Time),
             CloseEnough = min(StartDiff, EndDiff) < overlapThresh) %>%
      ungroup()
    
    ##Add new timeslot ID: if not close enough, "Too far"; if close enough, closer
    ##  boundary (tie goes to start boundary); anything else is unexpected so it
    ##  triggers an error below
    overlapBounds <- overlapBounds %>% 
      mutate(NewTS = case_when(
          !CloseEnough ~ "Too far",
          StartDiff <= EndDiff ~ TIME_SLOT_REF1_overlapped,
          StartDiff > EndDiff ~ TIME_SLOT_REF2_overlapped,
          TRUE ~ NA_character_),
        ##Add node path for fixing overlap
        NodePath = str_glue("//ALIGNABLE_ANNOTATION[@ANNOTATION_ID='{ANNOTATION_ID}']") %>% 
          as.character())
  } else {
    overlapBounds <- overlapBounds %>% 
      mutate(StartDiff = double(0L),
             EndDiff = double(0L),
             CloseEnough = logical(0L),
             NewTS = character(0L),
             NodePath = character(0L))
  }
  
  ##Return dataframe (which may be 0-row)
  overlapBounds
}
```

```{r rewrite-fixOverlaps-1}
# fixOverlaps <- function(eafName, tierOrder, eaflist, tierInfo) {
fixOverlaps <- function(eafName, tierOrder, eaflist) {
  ##Get initial overlaps
  overlapsInit <- 
    ##Get tier names
    eaflist %>%
    xmllist_to_df(singleDF=F) %>% 
    pluck(eafName) %>% 
    findOverlaps(eafName)
  
  ##Ensure tierOrder matches overlapsInit names
  if (!identical(sort(names(overlapsInit)),
                 sort(tierOrder))) {
    stop("names(overlapsInit): ", names(overlapsInit), 
         "\ntierOrder: ", tierOrder)
  }
  
  ##Initialize looping variables
  overlapsPre <- NULL
  overlapsPost <- overlapsInit
  iters <- 0
  maxIter <- 10
  
  ##Continue until there are no remaining overlaps, either because all
  ##  overlaps have been fixed, or because things have stablized
  while (any(map_int(overlapsPost, nrow) > 0) && !identical(overlapsPre, overlapsPost)) {
    ##Increment iteration counter & stop if above maxIter
    iters <- iters + 1
    if (iters > maxIter) {
      stop("Overlap fixing reached max iterations (", maxIter, ")")
    }
    
    ##Old post is new pre
    overlapsPre <- overlapsPost
    
    ##Fix each tier in turn
    for (tier in tierOrder) {
    # for (tier in rev(tierOrder)) {
      message(tier)
      ##Re-assess overlaps now that eaflist has been modified
      overlapsCurr <- 
        eaflist %>%
        xmllist_to_df(singleDF=F) %>% 
        pluck(eafName) %>% 
        findOverlaps(eafName)
      
      ##Hide overlaps in all other tiers from fixOverlapsTier()
      for (otherSpkr in setdiff(names(overlapsPre), tier)) {
        overlapsCurr <- overlapsCurr %>% 
          modify_in(list(otherSpkr), ~ .x %>% filter(is.na(ANNOTATION_ID)))
      }
      
      ##Fix overlaps for *other* tiers, keeping current tier
      overlapsPost[[tier]] <-
        overlapsMid %>% 
        map(fixOverlapsTier, eaflist, eafName) %>% 
        pluck(tier) %>% 
        filter(!Resolved)
    }
    
    message("iters: ", iters)
    message("nrow(overlapsPre): ", map_int(overlapsPre, nrow) %>% paste(collapse=" "))
    message("nrow(overlapsPost): ", map_int(overlapsPost, nrow) %>% paste(collapse=" "))
  }
  
  ##Return overlapsPost
  overlapsPost
}
```




# Fix both boundaries being snapped to 9362 r/t 9300 (29 Sep 2022)

Let's see what we get now:

```{r}
eaflist <- c(Orig = "../APLS Elan File Checker/tests/shinytest/step3/HD06-1_GoodOnly.eaf") %>% 
  map(read_xml)
fixOverlaps("Orig", c("HD06", "Interviewer HD06"), eaflist)
eaflist %>% 
  xmllist_to_df() %>% 
  filter(ANNOTATION_ID %in% c("a7", "a10"))
```

Okay, need to change something in the function (I renamed `overlapsMid` to `overlapsCurr`).
Hopefully that's the entirety of the problem!

```{r rewrite-fixOverlaps-2}
# fixOverlaps <- function(eafName, tierOrder, eaflist, tierInfo) {
fixOverlaps <- function(eafName, tierOrder, eaflist) {
  ##Get initial overlaps
  overlapsInit <- 
    ##Get tier names
    eaflist %>%
    xmllist_to_df(singleDF=F) %>% 
    pluck(eafName) %>% 
    findOverlaps(eafName)
  
  ##Ensure tierOrder matches overlapsInit names
  if (!identical(sort(names(overlapsInit)),
                 sort(tierOrder))) {
    stop("tierOrder")
  }
  
  ##Initialize looping variables
  overlapsPre <- NULL
  overlapsPost <- overlapsInit
  iters <- 0
  maxIter <- 10
  
  ##Continue until there are no remaining overlaps, either because all
  ##  overlaps have been fixed, or because things have stablized
  while (any(map_int(overlapsPost, nrow) > 0) && !identical(overlapsPre, overlapsPost)) {
    ##Increment iteration counter & stop if above maxIter
    iters <- iters + 1
    if (iters > maxIter) {
      stop("Overlap fixing reached max iterations (", maxIter, ")")
    }
    
    ##Old post is new pre
    overlapsPre <- overlapsPost
    
    ##Fix each tier in turn
    for (tier in tierOrder) {
    # for (tier in rev(tierOrder)) {
      message(tier)
      ##Re-assess overlaps now that eaflist has been modified
      overlapsCurr <- 
        eaflist %>%
        xmllist_to_df(singleDF=F) %>% 
        pluck(eafName) %>% 
        findOverlaps(eafName)
      
      ##Hide overlaps in all other tiers from fixOverlapsTier()
      for (otherSpkr in setdiff(names(overlapsPre), tier)) {
        overlapsCurr <- overlapsCurr %>% 
          modify_in(list(otherSpkr), ~ .x %>% filter(is.na(ANNOTATION_ID)))
      }
      
      ##Fix overlaps for *other* tiers, keeping current tier
      overlapsPost[[tier]] <-
        overlapsCurr %>% 
        map(fixOverlapsTier, eaflist, eafName) %>% 
        pluck(tier) %>% 
        filter(!Resolved)
    }
    
    message("iters: ", iters)
    message("nrow(overlapsPre): ", map_int(overlapsPre, nrow) %>% paste(collapse=" "))
    message("nrow(overlapsPost): ", map_int(overlapsPost, nrow) %>% paste(collapse=" "))
  }
  
  ##Return overlapsPost
  overlapsPost
}
```


```{r}
eaflist <- c(Orig = "../APLS Elan File Checker/tests/shinytest/step3/HD06-1_GoodOnly.eaf") %>% 
  map(read_xml)
fixOverlaps("Orig", c("HD06", "Interviewer HD06"), eaflist)
eaflist %>% 
  xmllist_to_df() %>% 
  filter(ANNOTATION_ID %in% c("a7", "a10"))
```

Awwww yeah!!!

# Does it actually do what I want it to?

To ensure this is actually working, I'm going to export eaflist and open it in Praat to check some of the boundaries

Then I'll try it with the other test files (the ones that have bad overlaps)

```{r}
eaflist <- c(Orig = "../APLS Elan File Checker/tests/shinytest/step3/HD06-1_GoodOnly.eaf") %>% 
  map(read_xml)
invisible(fixOverlaps("Orig", c("HD06", "Interviewer HD06"), eaflist))
eaflist %>% 
  pluck("Orig") %>% 
  write_xml("HD06-1_GoodOnly_out.eaf")
```

For my own reference, here's the overlaps:

```{r}
eaflist <- c(Orig = "../APLS Elan File Checker/tests/shinytest/step3/HD06-1_GoodOnly.eaf") %>% 
  map(read_xml)
eaflist %>% 
  xmllist_to_df(singleDF=F) %>% 
  pluck("Orig") %>% 
  findOverlaps() %>% 
  map(~ .x %>% mutate(across(Time, divide_by, 1000)))
```

## In which I come up with a way to compare old & new alignments in a single TG

Actually, it might be easier if I have both old & new in the same file.
How do I modify tier IDs again?

```{r}
eaflist_old <- c(Orig = "../APLS Elan File Checker/tests/shinytest/step3/HD06-1_GoodOnly.eaf") %>% 
  map(read_xml)
eaflist_old %>%
  pluck("Orig") %>% 
  xml_find_all("//TIER[@TIER_ID='Interviewer HD06']")
```

```{r}
##xml_set_attr() modifies without assignment (!!!)
c("HD06", "Interviewer HD06") %>% 
  ##walk() to avoid return value
  walk(~ eaflist_old %>%
         pluck("Orig") %>% 
         xml_find_all(str_glue("//TIER[@TIER_ID='{.x}']")) %>% 
         xml_set_attr("TIER_ID", str_glue("{.x}_old")))
##What are the tier IDs now?
eaflist_old %>% 
  pluck("Orig") %>% 
  xml_find_all("//TIER") %>% 
  map_chr(xml_attr, "TIER_ID")
```

Sweet. And new?

```{r}
eaflist_new <- c(Orig = "../APLS Elan File Checker/tests/shinytest/step3/HD06-1_GoodOnly.eaf") %>% 
  map(read_xml)
invisible(fixOverlaps("Orig", c("HD06", "Interviewer HD06"), eaflist_new))
c("HD06", "Interviewer HD06") %>% 
  walk(~ eaflist_new %>%
         pluck("Orig") %>% 
         xml_find_all(str_glue("//TIER[@TIER_ID='{.x}']")) %>% 
         xml_set_attr("TIER_ID", str_glue("{.x}_new")))
##What are the tier IDs now?
eaflist_new %>% 
  pluck("Orig") %>% 
  xml_find_all("//TIER") %>% 
  map_chr(xml_attr, "TIER_ID")
```

Now add the old to the new

```{r}
oldTiers <- 
  eaflist_old %>% 
  pluck("Orig") %>% 
  xml_find_all("//TIER[contains(@TIER_ID, '_old')]")
##This worked
oldTiers
##Indexing works
oldTiers[1]
##Tiers are children of the whole document
eaflist_new %>% 
  pluck("Orig") %>% 
  xml_children()
```


```{r}
##Does `xml_add_child()` modify without assignment?
eaflist_new %>% 
  pluck("Orig") %>% 
  xml_add_child(oldTiers[1], .where=2) %>% 
  xml_add_child(oldTiers[2], .where=4)
```

```{r}
as.character(oldTiers[1]) %>% 
  str_sub(1, 100)
```

```{r}
##Does `xml_add_child()` modify without assignment?
eaflist_new %>% 
  pluck("Orig") %>% 
  xml_add_child(as.character(oldTiers[1]), .where=2) %>% 
  xml_add_child(as.character(oldTiers[2]), .where=4)
##What are the tier IDs now?
eaflist_new %>% 
  pluck("Orig") %>% 
  xml_find_all("//TIER") %>% 
  map_chr(xml_attr, "TIER_ID")
```

~`xml_add_child()` apparently doesn't modify without assignment~ (Later, I realize I'm wrong)

```{r}
eaflist_new$Orig <- eaflist_new$Orig %>% 
  xml_add_child(as.character(oldTiers[1]), .where=2) %>% 
  xml_add_child(as.character(oldTiers[2]), .where=4)
##What are the tier IDs now?
eaflist_new %>% 
  pluck("Orig") %>% 
  xml_find_all("//TIER") %>% 
  map_chr(xml_attr, "TIER_ID")
```


Huh. The `xml_add_child()` helpfile is example-less, but the node-modification vignette has:

```{r}
x <- read_xml("<parent><child>1</child><child>2<child>3</child></child></parent>")
x
children <- xml_children(x)
t1 <- children[[1]]
t2 <- children[[2]]
t3 <- xml_children(children[[2]])[[1]]

xml_add_child(t1, t3)
x

xml_add_child(t1, read_xml("<test/>"))
x
```

So it **does** modify without assignment.
Maybe the issue is passing the whole document rather than a nodeset.
What if I explicitly select the root node?

```{r}
eaflist_new %>% 
  pluck("Orig")
eaflist_new %>% 
  pluck("Orig") %>% 
  xml_find_all("/")
```

Maybe re-read `eaflist_new`?

```{r}
eaflist_new <- c(Orig = "../APLS Elan File Checker/tests/shinytest/step3/HD06-1_GoodOnly.eaf") %>% 
  map(read_xml)
invisible(fixOverlaps("Orig", c("HD06", "Interviewer HD06"), eaflist_new))
c("HD06", "Interviewer HD06") %>% 
  walk(~ eaflist_new %>%
         pluck("Orig") %>% 
         xml_find_all(str_glue("//TIER[@TIER_ID='{.x}']")) %>% 
         xml_set_attr("TIER_ID", str_glue("{.x}_new")))
eaflist_new %>% 
  pluck("Orig")
eaflist_new %>% 
  pluck("Orig") %>% 
  xml_find_all("/")
```

Ahhh, they're not children of the _root_, they're children of `ANNOTATION_DOCUMENT`!

```{r}
eaflist_new %>% 
  pluck("Orig") %>% 
  xml_find_all("ANNOTATION_DOCUMENT")
```

Oh, or they're not?

```{r}
eaflist_new %>% 
  pluck("Orig") %>% 
  xml_find_all("/") %>% 
  xml_children()
eaflist_new %>% 
  pluck("Orig") %>% 
  xml_find_all("/") %>% 
  xml_children() %>% 
  xml_children()
```

Oh duh, I need the `//` (I guess `/` would also do here)

```{r}
eaflist_new %>% 
  pluck("Orig") %>% 
  xml_find_all("//ANNOTATION_DOCUMENT")
eaflist_new %>% 
  pluck("Orig") %>% 
  xml_find_all("/ANNOTATION_DOCUMENT")
```

Okay, sooooo

```{r}
eaflist_new %>% 
  pluck("Orig") %>% 
  xml_find_all("/ANNOTATION_DOCUMENT") %>% 
  xml_add_child(as.character(oldTiers[1]), .where=2) %>% 
  xml_add_child(as.character(oldTiers[2]), .where=4)
##What are the tier IDs now?
eaflist_new %>% 
  pluck("Orig") %>% 
  xml_find_all("//TIER") %>% 
  map_chr(xml_attr, "TIER_ID")
```


Um. Is it the `as.character()`? Yes!

```{r}
eaflist_new <- c(Orig = "../APLS Elan File Checker/tests/shinytest/step3/HD06-1_GoodOnly.eaf") %>% 
  map(read_xml)
invisible(fixOverlaps("Orig", c("HD06", "Interviewer HD06"), eaflist_new))
c("HD06", "Interviewer HD06") %>% 
  walk(~ eaflist_new %>%
         pluck("Orig") %>% 
         xml_find_all(str_glue("//TIER[@TIER_ID='{.x}']")) %>% 
         xml_set_attr("TIER_ID", str_glue("{.x}_new")))
eaflist_new %>% 
  pluck("Orig") %>% 
  xml_find_all("/ANNOTATION_DOCUMENT") %>% 
  xml_add_child(oldTiers[1], .where=2) %>% 
  xml_add_child(oldTiers[2], .where=4)
##What are the tier IDs now?
eaflist_new %>% 
  pluck("Orig") %>% 
  xml_find_all("//TIER") %>% 
  map_chr(xml_attr, "TIER_ID")
```

But Interviewer HD06_new isn't showing up in the right spot (maybe it's a child of HD06_old now):

```{r}
eaflist_new %>% 
  pluck("Orig") %>% 
  xml_children()
```

```{r}
eaflist_new <- c(Orig = "../APLS Elan File Checker/tests/shinytest/step3/HD06-1_GoodOnly.eaf") %>% 
  map(read_xml)
invisible(fixOverlaps("Orig", c("HD06", "Interviewer HD06"), eaflist_new))
c("HD06", "Interviewer HD06") %>% 
  walk(~ eaflist_new %>%
         pluck("Orig") %>% 
         xml_find_all(str_glue("//TIER[@TIER_ID='{.x}']")) %>% 
         xml_set_attr("TIER_ID", str_glue("{.x}_new")))
oldTiers %>% 
  iwalk(~ eaflist_new %>% 
          pluck("Orig") %>% 
          xml_find_all("/ANNOTATION_DOCUMENT") %>% 
          xml_add_child(.x, .where=2*.y))
eaflist_new %>% 
  pluck("Orig") %>% 
  xml_find_all("/ANNOTATION_DOCUMENT/TIER") %>% 
  map_chr(xml_attr, "TIER_ID")
```

Beauty.

I could remove the non-speaker tiers, but it's easy to do that in ELAN anyway.

```{r}
write_xml(eaflist_new$Orig, "HD06-1_GoodOnly_oldnew.eaf")
```

(In Elan, it's File > Export As > Praat TextGrid.)

Also, next time use - r/t _ for the separator bec Praat treats that as a subscript indicator


## So? Did it work?

It looks like it! 
With a few caveats:

- I was wrong---setting HD06 to `NA` first **did** snap Int to HD06! 
  - I was just completely reading the results wrong in section 4.1. Each row from findOverlaps() is an annotation that _**commits** an overlap_, not an annotation that _is overlapp**ed**_
  - That's an easy fix. Just reverse the tier order. (It seemed like `rev(tierOrder)` wasn't working yesterday, but that could've just been the `overlapsMid` bug)
- The overlap around 107s: 2 overlaps show up for a single HD06 boundary (shared by consecutive turns), but only the right-side one is fixed for HD06, then the left-side one is fixed for Int
  - This is unexpected, but I'm not sure if it's actually a problem. Maybe looking at the bad-overlaps files will unearth an issue here, maybe not

Okay, without comprehensively checking all 200-odd overlaps, I'm satisfied!

### Reverse the tier order?

I'm going to just try reversing the tier order and see what happens!
Also, I'm adding a `monitor` switch to optionally suppress printing iterations info

```{r rewrite-fixOverlaps-3}
fixOverlaps <- function(eafName, tierOrder, eaflist, monitor=TRUE) {
  ##Get initial overlaps
  overlapsInit <- 
    ##Get tier names
    eaflist %>%
    xmllist_to_df(singleDF=F) %>% 
    pluck(eafName) %>% 
    findOverlaps(eafName)
  
  ##Ensure tierOrder matches overlapsInit names
  if (!identical(sort(names(overlapsInit)),
                 sort(tierOrder))) {
    stop("tierOrder")
  }
  
  ##Initialize looping variables
  overlapsPre <- NULL
  overlapsPost <- overlapsInit
  iters <- 0
  maxIter <- 10
  
  ##Continue until there are no remaining overlaps, either because all
  ##  overlaps have been fixed, or because things have stablized
  while (any(map_int(overlapsPost, nrow) > 0) && !identical(overlapsPre, overlapsPost)) {
    ##Increment iteration counter & stop if above maxIter
    iters <- iters + 1
    if (iters > maxIter) {
      stop("Overlap fixing reached max iterations (", maxIter, ")")
    }
    
    ##Old post is new pre
    overlapsPre <- overlapsPost
    
    ##Fix each tier in turn
    # for (tier in tierOrder) {
    for (tier in rev(tierOrder)) {
      message(tier)
      ##Re-assess overlaps now that eaflist has been modified
      overlapsCurr <- 
        eaflist %>%
        xmllist_to_df(singleDF=F) %>% 
        pluck(eafName) %>% 
        findOverlaps(eafName)
      
      ##Hide overlaps in all other tiers from fixOverlapsTier()
      for (otherSpkr in setdiff(names(overlapsPre), tier)) {
        overlapsCurr <- overlapsCurr %>% 
          modify_in(list(otherSpkr), ~ .x %>% filter(is.na(ANNOTATION_ID)))
      }
      
      ##Fix overlaps for *other* tiers, keeping current tier
      overlapsPost[[tier]] <-
        overlapsCurr %>% 
        map(fixOverlapsTier, eaflist, eafName) %>% 
        pluck(tier) %>% 
        filter(!Resolved)
    }
    
    if (monitor) {
      message("iters: ", iters)
      message("nrow(overlapsPre): ", map_int(overlapsPre, nrow) %>% paste(collapse=" "))
      message("nrow(overlapsPost): ", map_int(overlapsPost, nrow) %>% paste(collapse=" "))
    }
  }
  
  ##Return overlapsPost
  overlapsPost
}
```


```{r}
eaflist <- c(Orig = "../APLS Elan File Checker/tests/shinytest/step3/HD06-1_GoodOnly.eaf") %>% 
  map(read_xml)
invisible(fixOverlaps("Orig", c("HD06", "Interviewer HD06"), eaflist))
eaflist %>% 
  xmllist_to_df() %>% 
  filter(ANNOTATION_ID %in% c("a7", "a10"))
```

Great! Now Int has been snapped to HD06

Check that it looks okay:

```{r}
##Make sure the ... thing works
##... is eafName=eafPath
compareEAFs <- function(..., tiers=c("HD06", "Interviewer HD06")) {
  paths <- list(...)
  paths
}
##Yup:
compareEAFs(Orig = "../APLS Elan File Checker/tests/shinytest/step3/HD06-1_GoodOnly.eaf",
            Bad = "../APLS Elan File Checker/tests/shinytest/step3/HD06-1_BadContainment.eaf")
```


```{r}
compareEAFs <- function(..., eafDir=".", outFile=NULL, tiers=c("HD06", "Interviewer HD06")) {
  ##Read eaflist (two copies)
  paths <- list(...)
  eaflist_new <- eaflist_old <- paths %>% 
    map(~ paste0(eafDir, "/", .x) %>% 
          read_xml)
  
  ##Tag eaflist_old tiers w/ -old suffix
  for (eaf in eaflist_old) { ##Sorry not sorry
    tiers %>% 
      walk(~ eaf %>% 
             xml_find_all(str_glue("//TIER[@TIER_ID='{.x}']")) %>% 
             xml_set_attr("TIER_ID", str_glue("{.x}-old")))
  }
  ##Get just those tiers from eaflist_old
  oldTiers <- map(eaflist_old, xml_find_all, "//TIER[contains(@TIER_ID, '-old')]")
  
  ##Fix overlaps in eaflist_new
  iwalk(eaflist_new, ~ fixOverlaps(.y, tiers, .x))
  
  ##Tag eaflist_new tiers w/ -new suffix
  for (eaf in eaflist_new) { ##Sorry not sorry
    tiers %>% 
      walk(~ eaf %>% 
             xml_find_all(str_glue("//TIER[@TIER_ID='{.x}']")) %>% 
             xml_set_attr("TIER_ID", str_glue("{.x}-new")))
  }
  
  ##Add -old tiers to eaflist_new elements
  # With just one element in eaflist_new it's:
  # oldTiers %>% 
  #   iwalk(~ eaflist_new %>% 
  #           pluck("Orig") %>% 
  #           xml_find_all("/ANNOTATION_DOCUMENT") %>% 
  #           xml_add_child(.x, .where=2*.y))
}
```

And here I ran out of steam trying to figure out how to make eaflist_new & tiers cross one another.
`purrr::cross2()` looks promising for both this bit and the for-loops.
It's time to hang it up for today, though

### Getting back at it (30 Sep)

```{r}
paths <- list(Orig = "../APLS Elan File Checker/tests/shinytest/step3/HD06-1_GoodOnly.eaf",
              Bad = "../APLS Elan File Checker/tests/shinytest/step3/HD06-1_BadContainment.eaf")
eaflist_new <- eaflist_old <- paths %>%
  map(read_xml)
tiers <- c("HD06", "Interviewer HD06")
cross2(eaflist_old, tiers) %>% 
  str(2)
```

I guess `cross2()` doesn't preserve names, BOO.
`?cross` recommends "encapsulate the arguments in a named list before crossing to get named components".
But that doesn't produce the result I'd expect:

```{r}
list(vers = eaflist_old, tier = tiers) %>% 
  cross() %>% 
  str(2)
```

Actually, do I need names per se?

```{r}
list(eaf = eaflist_old, tier = tiers) %>% 
  cross() %>% 
  pmap(function(eaf, tier) {
    eaf %>% 
      xml_find_all(str_glue("//TIER[@TIER_ID='{tier}']")) %>% 
      xml_set_attr("TIER_ID", str_glue("{tier}-old"))
  })
eaflist_old %>%
  map(~ .x %>% 
        xml_find_all("/ANNOTATION_DOCUMENT/TIER") %>% 
        map_chr(xml_attr, "TIER_ID")
  )
```

Yeah, to hell with this.
Make a function that works for one file, then I can just `map()` over it!

```{r}
compareEAF <- function(x, save=FALSE, tiers=c("HD06", "Interviewer HD06")) {
  ##Read eaf (two copies)
  eaf_new <- read_xml(x)
  eaf_old <- read_xml(x)
  
  ##Fix overlaps in eaf_new
  invisible(fixOverlaps("eaf", tiers, list(eaf = eaf_new), monitor=FALSE))
  
  ##Tag eaf_old tiers with -old suffix
  tiers %>% 
    walk(~ eaf_old %>% 
           xml_find_all(str_glue("//TIER[@TIER_ID='{.x}']")) %>% 
           xml_set_attr("TIER_ID", str_glue("{.x}-old")))
  
  ##Get just those tiers from eaf_old
  oldTiers <- xml_find_all(eaf_old, "//TIER[contains(@TIER_ID, '-old')]")
  
  ##Tag eaf_new tiers with -new suffix
  tiers %>% 
    walk(~ eaf_new %>% 
           xml_find_all(str_glue("//TIER[@TIER_ID='{.x}']")) %>% 
           xml_set_attr("TIER_ID", str_glue("{.x}-new")))
  
  ##Add -old tiers to eaf_new elements
  oldTiers %>%
    iwalk(~ eaf_new %>%
            xml_find_all("/ANNOTATION_DOCUMENT") %>%
            xml_add_child(.x, .where=2*.y))
  
  if (save) {
    write_xml(eaf_new, str_replace(x, "\\.eaf$", "_oldnew.eaf"))
  } else {
    eaf_new
  }
}
```

```{r}
compareEAF("../APLS Elan File Checker/tests/shinytest/step3/HD06-1_GoodOnly.eaf")
```

Wait, why are both tiers `-old`?
It turns out it's because I needed to read the eaf twice so it wouldn't just be the same thing

Does it work with `map()`?

```{r}
dir("../APLS Elan File Checker/tests/shinytest/step3/", pattern="Bad.+eaf", full.names=TRUE) %>% 
  map(compareEAF) %>% 
  map(~ .x %>% 
        xml_find_all("//TIER") %>% 
        map_chr(xml_attr, "TIER_ID"))
```



## Now try it with "bad-overlaps" files


```{r}
dir("../APLS Elan File Checker/tests/shinytest/step3/", pattern="Bad.+eaf", full.names=TRUE) %>% 
  map(compareEAF, save=TRUE)
```

Looks solid!

# Integration issues (3 Oct)

I've hit a few snags trying to integrate the new fixO:

- The conflict between the old and new arguments means it's not a drop-in replacement.
- In this scratchpad I've been supplying tierOrder manually, but the app should do it dynamically (potentially with a parameter controlling the default order).
- I tried to add Redaction in one go, and it's possible there was an issue with the rewritten findOverlapsTier.

In short, I bit off more than I could chew!
(Right now the result of my flailing-about is being stowed away in the branch `fix-fixoverlaps`.)

## Use old arguments

So for now, try just using old arguments (plus 'hard-wire' monitor to TRUE and tierOrder to the preferred order).
Don't worry about Redaction yet, and keep findOverlapsTier as-is.

Original comment text:

> Wrapper function around fixOverlapsTier() that takes a *list* of DFs of
annotation times (one file's worth) and a single EAF name (meant to be used
with output of getTimes() and imap()), and rotates through tiers, fixing
overlaps, until it reaches a stable state

First, get the output of `getTimes()` and `imap()`, as it would be created in `overlapsIssues()`.
This takes `x` (`eaflist()`) and `df` (`tierInfo()`).
For df I'll just read from an output JSON, because the left join requires `fileDF` (created by the Shiny `fileInput()` UI element)

```{r}
library(jsonlite)
tierInfo <- fromJSON("../APLS Elan File Checker/tests/shinytest/test-step3-expected/HD06-1_GoodOnly.eaf.json") %>% 
  pluck("export", "tierInfo")
tierInfo
##Can't use Orig because of join w/ tierInfo
eaflist <- c("HD06-1_GoodOnly.eaf" = "../APLS Elan File Checker/tests/shinytest/step3/HD06-1_GoodOnly.eaf") %>% 
  map(read_xml)

# times <- imap(x, getTimes, df=df)
times <- imap(eaflist, getTimes, df=tierInfo)
str(times, 2)
```

I should've done this a while ago!

In `overlapsIssues()`, there's the following chain before fixO:

```{r}
# fixed <- 
  # x %>% 
  eaflist %>% 
  names() %>% 
  set_names(., .)# %>% 
  # ##Fix overlaps
  # map(~ fixOverlaps(times[[.x]], x, .x) %>% 
  #       ##All in one DF
  #       bind_rows(.id="Tier"))
```

So it's just looping over eaflist names.

Um, why not just `imap()` over `times`?
I just integrated that into the app, and it _appears_ to work.
Now I'm going to try it more formally with test-step3.R...and sweet! No changes.

(NB I will have to update the expected test results because they still create gaps!)

I could actually use this to bridge the gap between old and new args sooner r/t later, maybe?



```{r rewrite-fixoverlaps-4, eval=FALSE, include=FALSE}
HASN'T BEEN REWRITTEN YET!

# fixOverlaps <- function(eafName, tierOrder, eaflist, monitor=TRUE) {
fixOverlaps <- function(timesEAF, eaflist, eafName, 
                        ##Temporarily 'hard-wired' args
                        tierOrder=c("HD06", "Interviewer HD06"), monitor=TRUE) {
  ##Get initial overlaps
  overlapsInit <- 
    ##Get tier names
    eaflist %>%
    xmllist_to_df(singleDF=F) %>% 
    pluck(eafName) %>% 
    findOverlaps(eafName)
  
  ##Ensure tierOrder matches overlapsInit names
  if (!identical(sort(names(overlapsInit)),
                 sort(tierOrder))) {
    stop("tierOrder")
  }
  
  ##Initialize looping variables
  overlapsPre <- NULL
  overlapsPost <- overlapsInit
  iters <- 0
  maxIter <- 10
  
  ##Continue until there are no remaining overlaps, either because all
  ##  overlaps have been fixed, or because things have stablized
  while (any(map_int(overlapsPost, nrow) > 0) && !identical(overlapsPre, overlapsPost)) {
    ##Increment iteration counter & stop if above maxIter
    iters <- iters + 1
    if (iters > maxIter) {
      stop("Overlap fixing reached max iterations (", maxIter, ")")
    }
    
    ##Old post is new pre
    overlapsPre <- overlapsPost
    
    ##Fix each tier in turn
    # for (tier in tierOrder) {
    for (tier in rev(tierOrder)) {
      message(tier)
      ##Re-assess overlaps now that eaflist has been modified
      overlapsCurr <- 
        eaflist %>%
        xmllist_to_df(singleDF=F) %>% 
        pluck(eafName) %>% 
        findOverlaps(eafName)
      
      ##Hide overlaps in all other tiers from fixOverlapsTier()
      for (otherSpkr in setdiff(names(overlapsPre), tier)) {
        overlapsCurr <- overlapsCurr %>% 
          modify_in(list(otherSpkr), ~ .x %>% filter(is.na(ANNOTATION_ID)))
      }
      
      ##Fix overlaps for *other* tiers, keeping current tier
      overlapsPost[[tier]] <-
        overlapsCurr %>% 
        map(fixOverlapsTier, eaflist, eafName) %>% 
        pluck(tier) %>% 
        filter(!Resolved)
    }
    
    if (monitor) {
      message("iters: ", iters)
      message("nrow(overlapsPre): ", map_int(overlapsPre, nrow) %>% paste(collapse=" "))
      message("nrow(overlapsPost): ", map_int(overlapsPost, nrow) %>% paste(collapse=" "))
    }
  }
  
  ##Return overlapsPost
  overlapsPost
}
```



# Session info

```{r}
sessionInfo()
```


