---
title: APLS shinytest Scratchpad 1
output: 
  html_notebook:
    toc: yes
    toc_float: yes
    number_sections: yes
    code_folding: hide
    df_print: tibble
---

```{r setup}
knitr::opts_chunk$set(echo=T, include=T, comment=NA)
library(tidyverse)
library(shiny)
library(shinytest)
library(xml2)
```

# Intro

From my TODO:

- Order tiers by importance (main speaker(s) > interviewer > bystander(s)), and align overlaps from least important to most important
  - Add new test files: Ensure interviewer is snapped to main speaker(s)
  - So I can eventually add Redaction as the highest priority (since we need to delete exactly the right audio)
  
First, the necessary functions:

```{r}
nonSpkrTiers <- c("Comment","Noise","Redaction")
overlapThresh <- 500

##Function that takes a tier name, eaf file, and file-wide time slot DF as
##  input and outputs actual times for annotations
getTimesTier <- function(tierName, eaf, timeSlots) {
  tierTimes <-
    ##Get all ALIGNABLE_ANNOTATION tags
    str_glue("//TIER[@TIER_ID='{tierName}']//ALIGNABLE_ANNOTATION") %>%
    xml_find_all(eaf, .) %>% 
    ##Get attributes as a dataframe
    xml_attrs() %>% 
    bind_rows()
  
  ##Add actual times, only if tier is nonempty
  if (nrow(tierTimes) > 0) {
    tierTimes <- tierTimes %>% 
      ##Add actual times
      left_join(timeSlots %>%
                  rename(TIME_SLOT_REF1 = TIME_SLOT_ID,
                         Start = TIME_VALUE),
                by="TIME_SLOT_REF1") %>%
      left_join(timeSlots %>%
                  rename(TIME_SLOT_REF2 = TIME_SLOT_ID,
                         End = TIME_VALUE),
                by="TIME_SLOT_REF2")
  } else {
    ##If tier is empty, return NULL (will be immediately discard()ed)
    NULL
  }
}

##Wrapper function around getTimesTier() that takes a single EAF file and name
##  (meant to be used with eaflist() reactive and imap()) plus multi-file tier
##  df (meant to be used with tierInfo() reactive) as input, and outputs nested
##  list of dataframes of annotation times (files at level one, tier DFs at
##  level two for speaker tiers only)
##N.B. This function outputs a list of DFs rather than a single DF because the
##  list structure makes it easier to detect overlaps in findOverlaps() (by
##  comparing the timings on a given speaker tier to all other speaker tiers)
getTimes <- function(eaf, eafName, df) {
  ##Timeslots (maps time slot ID to actual time, in milliseconds)
  timeSlots <- 
    ##Get TIME_SLOT nodes
    eaf %>% 
    xml_find_all("//TIME_SLOT") %>% 
    ##Get attributes as a dataframe
    xml_attrs() %>% 
    bind_rows() %>% 
    ##Make actual time numeric
    mutate(across(TIME_VALUE, as.numeric))
  
  ##Get speaker tier names
  spkrTierNames <- 
    ##df intended to be tierInfo() reactive
    df %>% 
    filter(File==eafName, SpkrTier) %>% 
    pull(TIER_ID)
  
  ##Get times for speaker tiers (list of dataframes)
  spkrTimes <- 
    spkrTierNames %>% 
    set_names(., .) %>% 
    map(getTimesTier, eaf, timeSlots) %>%
    ##Only nonempty tiers
    discard(is.null)
}

##Function that takes a single tier name and a nested list of annotation time
##  DFs (meant to be used with output of getTimes()), and outputs a single
##  dataframe: the relevant annotation time DF plus three boolean overlaps
##  columns (left, right, both), where TRUE means there is at least one
##  annotation on another tier whose (e.g.) left boundary is within the
##  annotation
findOverlapsTier <- function(tierName, timesEAF) {
  ##Get annotation timing DF for selected speaker
  spkr <- timesEAF %>% pluck(tierName)
  ##Get annotation timing DF that combines all other speakers
  otherSpkrs <-
    timesEAF %>%
    extract(names(.) != tierName) %>%
    bind_rows()
  
  ##For each boundary in selected tier, return the first annotation that the
  ##  boundary overlaps with, if any
  ##Currently isn't guaranteed to work with 3+ speaker tiers (because
  ##  which(x)[1] only selects the first result, not necessarily the result
  ##  closest to the boundary)
  bounds <- 
    spkr %>%
    ##One row per boundary (new columns Side, TIME_SLOT_REF, Time)
    rename(Time1 = Start, Time2 = End) %>% 
    pivot_longer(-ANNOTATION_ID, 
                 names_to=c(".value", "Side"), names_pattern="(.+)([12])") %>% 
    ##Check row-by-row (otherwise comparison in which() doesn't work)
    rowwise() %>% 
    ##Add overlap annotation ID
    ##N.B. This works because if which(x) is integer(0), which(x)[1] is NA
    mutate(ANNOTATION_ID_overlapped = otherSpkrs$ANNOTATION_ID %>% 
             extract(which(Time > otherSpkrs$Start & Time < otherSpkrs$End)[1])) %>% 
    ungroup()
  
  ##Restrict to boundaries with overlaps, and add information about overlapped
  ##  annotations
  overlapBounds <- 
    bounds %>%
    ##Only the boundaries that overlap another annotation
    filter(!is.na(ANNOTATION_ID_overlapped)) %>% 
    ##Add info about overlapped annotation
    left_join(otherSpkrs %>%
                rename_with(~ paste0(.x, "_overlapped")),
              by="ANNOTATION_ID_overlapped") %>% 
    ##Determine whether the nearest boundary is close enough (rowwise for min())
    rowwise() %>%
    mutate(StartDiff = abs(Start_overlapped - Time),
           EndDiff = abs(End_overlapped - Time),
           CloseEnough = min(StartDiff, EndDiff) < overlapThresh) %>%
    ungroup()
  
  ##Add new timeslot ID: if not close enough, "Too far"; if close enough, closer
  ##  boundary (tie goes to start boundary); anything else is unexpected so it
  ##  triggers an error below
  overlapBounds <- overlapBounds %>% 
    mutate(NewTS = case_when(
      !CloseEnough ~ "Too far",
      StartDiff <= EndDiff ~ TIME_SLOT_REF1_overlapped,
      StartDiff > EndDiff ~ TIME_SLOT_REF2_overlapped,
      TRUE ~ NA_character_),
      ##Add node path for fixing overlap
      NodePath = str_glue("//ALIGNABLE_ANNOTATION[@ANNOTATION_ID='{ANNOTATION_ID}']"))
  
  ##Return dataframe
  overlapBounds
}

##Check for problems with overlapBounds, fix any overlaps by modifying eaflist(),
##  and return overlapBounds with info about fixed boundaries
fixOverlapsTier <- function(overlapBounds, eaflist, eafName) {
  ##Check for boundaries where NewTS is NA
  if (any(is.na(overlapBounds$NewTS))) {
    stop("On tier ", tierName, 
         ", at least one boundary returned an error: ",
         overlapBounds %>% 
           filter(is.na(NewTS)) %>% 
           pull(ANNOTATION_ID) %>% 
           paste(collapse=" "))
  }
  
  ##Get fixed boundaries only
  overlapBoundsFixed <- 
    overlapBounds %>% 
    filter(NewTS != "Too far")
  
  ##If no boundaries fixed, return dataframe with all unresolved
  if (nrow(overlapBoundsFixed)==0) {
    overlapBounds <- overlapBounds %>% 
      mutate(Resolved = FALSE)
    return(overlapBounds)
  }
  
  ##Otherwise, check for issues in overlaps
  ##Check for annotation IDs that don't select a unique node within EAF file
  nodeCount <- 
    overlapBoundsFixed$NodePath %>% 
    map_int(~ xml_find_all(eaflist[[eafName]], .x) %>% 
              xml_length())
  if (any(nodeCount > 1)) {
    stop("On tier ", tierName, 
         ", at least one annotation ID doesn't select a unique node: ",
         overlapBoundsFixed %>% 
           filter(NodeCount > 1) %>% 
           pull(ANNOTATION_ID) %>% 
           paste(collapse=" "))
  }
  
  ##Check for annotations that have accidentally become 0-width
  ##This could happen if the annotation is less than overlapThresh wide and
  ##  is fully contained within another annotation on another tier. Could
  ##  mitigate this by re-running with a smaller overlapThresh
  zeroWidth <- 
    overlapBoundsFixed %>%
    select(ANNOTATION_ID:Time, NewTS) %>%
    pivot_wider(names_from=Side, names_glue="{.value}{Side}",
                values_from=TIME_SLOT_REF:NewTS) %>%
    filter(NewTS1==NewTS2)
  if (nrow(zeroWidth) > 0) {
    stop("On tier ", tierName, 
         ", at least one annotation was fixed to zero width:\n",
         "ANN_ID  Start   End\n",
         paste0(str_pad(zeroWidth$ANNOTATION_ID, 8, 'right'),
                str_pad(round(zeroWidth$Time1 / 1000, 1), 8, 'right'),
                str_pad(round(zeroWidth$Time2 / 1000, 1), 8, 'right'),
                "\n"))
  }
  
  ##Fix overlaps in eaflist()
  overlapBoundsFixed %>% 
    rowwise() %>% 
    group_walk(
      ~ eaflist %>% 
        pluck(eafName) %>% 
        xml_find_first(.x$NodePath) %>%
        ##Note xml_set_attr() modifies without assignment (!!!)
        xml_set_attr(paste0("TIME_SLOT_REF", .x$Side), .x$NewTS))
  
  ##Add fixed info to dataframe
  overlapBounds <- overlapBounds %>% 
    mutate(Resolved = NewTS!="Too far")
  
  ##Return dataframe
  overlapBounds
}

##Wrapper function around getTimesTier() that takes a *list* of DFs of
##  annotation times (one files' worth) and a single EAF name (meant to be used
##  with output of getTimes() and imap()), and outputs a *single* DF with 
##  annotation times plus overlaps columns
findOverlaps <- function(timesEAF, eafName) {
  ##Loop over tiers within this file to get overlaps
  timesEAF %>%
    names() %>%
    set_names(., .) %>%
    map(findOverlapsTier, timesEAF=timesEAF)
}

##Wrapper function around fixOverlapsTier() that takes a *list* of DFs of
##  annotation times (one file's worth) and a single EAF name (meant to be used
##  with output of getTimes() and imap()), and rotates through tiers, fixing
##  overlaps, until it reaches a stable state
fixOverlaps <- function(timesEAF, eaflist, eafName) {
  # ##Initialize empty overlap log
  # overlapLog <- data.frame(Tier = character(), 
  #                          NumBounds = character(),
  #                          NumOverlaps = character(),
  #                          NumFixed = character())
  
  ##Get initial overlaps
  overlapsInit <- 
    ##Get tier names
    timesEAF %>%
    names() %>% 
    set_names(., .) %>%
    ##Loop over tier names to find overlaps
    map(findOverlapsTier, timesEAF)
  
  ##Initialize looping variables
  overlapsPre <- NULL
  overlapsPost <- overlapsInit
  iters <- 0
  maxIter <- 10
  
  ##Continue until there are no remaining overlaps, either because all
  ##  overlaps have been fixed, or because things have stablized
  while (any(map_int(overlapsPost, nrow) > 0) && !identical(overlapsPre, overlapsPost)) {
    ##Increment iteration counter & stop if above maxIter
    iters <- iters + 1
    if (iters > maxIter) {
      stop("Overlap fixing reached max iterations (", maxIter, ")")
    }
    
    ##Old post is new pre
    overlapsPre <- overlapsPost
    
    ##Go through another fixing round
    overlapsPost <- 
      overlapsPre %>%
      map(fixOverlapsTier, eaflist, eafName) %>% 
      map(filter, !Resolved)
    
    message("iters: ", iters)
    message("nrow(overlapsPre): ", map_int(overlapsPre, nrow) %>% paste(collapse=" "))
    message("nrow(overlapsPost): ", map_int(overlapsPost, nrow) %>% paste(collapse=" "))
  }
  
  ##Return overlapsPost
  overlapsPost
}

##To be used for interactive debugging, not in actual app
xmllist_to_df <- function(xmllist, singleDF=TRUE, nST=nonSpkrTiers) {
  tierInfo <- 
    xmllist %>% 
    map(xml_find_all, "//TIER") %>% 
    ##One row per tier, with file info
    map_dfr(~ map_dfr(.x, xml_attrs), .id="File") %>% 
    ##Add SpkrTier (is the tier a speaker tier?)
    mutate(SpkrTier = !(tolower(PARTICIPANT) %in% tolower(nST)))
  
  eaflist <- imap(xmllist, getTimes, df=tierInfo)
  
  if (singleDF) {
    eaflist %>%
      map_dfr(~ map_dfr(.x, as_tibble, .id="Tier"), .id="File")
  } else {
    eaflist
  }
}

##Get a dataframe from several paths to EAFs
eafs_to_df <- function(..., singleDF=TRUE, nST=nonSpkrTiers) {
  eaflist <- list(...) %>% 
    flatten_chr() %>% 
    set_names(make.names(basename(.), unique=TRUE)) %>% 
    map(read_xml)
  
  xmllist_to_df(eaflist, singleDF=singleDF, nST=nST)
}

##Get a dataframe from a directory with several EAFs
eafDir_to_df <- function(eafDir, pattern=".+\\.eaf$", 
                         singleDF=TRUE, nST=nonSpkrTiers) {
  eaflist <- 
    dir(eafDir, pattern=pattern, full.names=TRUE) %>% 
    set_names(basename(.)) %>% 
    map(read_xml)
  
  xmllist_to_df(eaflist, singleDF=singleDF, nST=nST)
}
```

Right, that's all!

Does putting the interviewer before the main speaker change how overlaps are fixed?

```{r}
orderDF <- 
  eafs_to_df("../APLS Elan File Checker/tests/shinytest/step3/HD06-1_GoodOnly.eaf",
             "../APLS Elan File Checker/tests/shinytest/test-step3-expected/HD06-1_GoodOnly_out.eaf",
             "../APLS Elan File Checker/tests/shinytest/test-step3-expected/HD06-1_GoodOnlyIntFirst_out.eaf") %>% 
  select(-contains("TIME_SLOT")) %>%
  mutate(across(File, forcats::fct_recode, 
                Orig = "HD06.1_GoodOnly.eaf",
                HD06First = "HD06.1_GoodOnly_out.eaf",
                IntFirst = "HD06.1_GoodOnlyIntFirst_out.eaf"))

orderDF %>% 
  pivot_longer(Start:End, names_to="Boundary") %>%
  pivot_wider(names_from=File) %>% 
  mutate(across(ends_with("First"), list(Change = ~ .x - Orig))) %>% 
  filter(if_any(ends_with("_Change"), ~ .x > 0))
orderDF %>% 
  pivot_longer(Start:End, names_to="Boundary") %>%
  pivot_wider(names_from=File) %>% 
  mutate(across(ends_with("First"), list(Change = ~ .x - Orig))) %>% 
  with(identical(HD06First_Change, IntFirst_Change))
```

Nope, it makes no difference.
So I'm going to just look at new vs. old

```{r}
newOld <-
  orderDF %>% 
  pivot_longer(Start:End, names_to="Boundary") %>%
  pivot_wider(names_from=File) %>% 
  select(-IntFirst) %>% 
  rename(Output = HD06First) %>% 
  mutate(Change = Output - Orig)
newOld
```

No apparent pattern by Tier or Boundary:

```{r}
newOld %>% 
  filter(Change!=0) %>% 
  ggplot(aes(x=Change, fill=Tier)) +
  geom_histogram(binwidth=5) +
  facet_grid(. ~ Boundary)
```

Instead, it looks like it's just whichever boundary comes first:

```{r}
newOld %>% 
  arrange(Orig) %>% 
  filter(Change!=0)
```

That said, I'm surprised that _both_ the boundaries move in a lot of these.
In the first two rows, a 62ms overlap turns into a 62ms gap.
But I want a 62ms overlap to turn into a 0ms gap.
Maybe that's because of the vectorized implementation; the Southland ones used a for-loop.

Try walking thru what `fixOverlaps()` does

This is like a single `times[[.x]]` element within the `map()` in `overlapsIssues()`---the thing that goes into each `fixOverlaps()`

```{r}
dfEAF <- eafs_to_df("../APLS Elan File Checker/tests/shinytest/step3/HD06-1_GoodOnly.eaf", 
                    singleDF=FALSE) %>% 
  pluck(1)
dfEAF %>% str(1)
eaflist <- c(Orig = "../APLS Elan File Checker/tests/shinytest/step3/HD06-1_GoodOnly.eaf") %>% 
  map(read_xml)
```

```{r}
fixO
```




# Session info

```{r}
sessionInfo()
```

